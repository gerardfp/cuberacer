<html> <head> <title>CubeRacer</title> <style> body { margin: 0; } canvas { width: 100%; height: 100% } </style> </head> <body> <script src="three.min.js"></script> 
    <script>
//=========================================================================
// MATH
//=========================================================================

function limit(value, min, max)     { return Math.max(min, Math.min(value, max)) }
function randomInt(min, max)        { return Math.round(interpolate(min, max, Math.random())) }
function randomChoice(options)      { return options[randomInt(0, options.length-1)] }
function percentRemaining(n, total) { return (n%total)/total }
function accelerate(v, accel, dt)   { return v + (accel * dt) }
function interpolate(a,b,percent)   { return a + (b-a)*percent }
function easeIn(a,b,percent)        { return a + (b-a)*Math.pow(percent,2) }
function easeOut(a,b,percent)       { return a + (b-a)*(1-Math.pow(1-percent,2)) }
function easeInOut(a,b,percent)     { return a + (b-a)*((-Math.cos(percent*Math.PI)/2) + 0.5) }  
        
        
//----------------------------
//
//----------------------------
var renderer = new THREE.WebGLRenderer({ alpha: true }); 
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.setClearColor( 0x7ec0ee, 1 );    
document.body.appendChild( renderer.domElement );    
        

// ----------------
// SCENE CAMERA LIGHTS
// ----------------
var cameraDistance = 10;
var cameraHeight = 6;
        
var scene = new THREE.Scene(); 
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );         

    
var light = new THREE.HemisphereLight(0xffffff, 0x555555, 1);
var light2 = new THREE.DirectionalLight( 0xffffff, 1 );
light.position.x -= 1000;
light.position.z += 100;

scene.add( light );
scene.add( light2 );
        
var axisHelper = new THREE.AxisHelper( 5 );
scene.add( axisHelper );      

var grid = new THREE.GridHelper(1000, 5);
scene.add(grid);

// var ground = new THREE.Mesh( 
//     new THREE.PlaneBufferGeometry( 100000, 100000 ),
//     new THREE.MeshBasicMaterial({ color:  0x10AA10, ambient: 0x333333 })
//   );
// ground.rotation.x = -Math.PI/2;
// scene.add(ground);
    
        
// --------------        
// CAR        
// --------------
        
var car = new THREE.Object3D();
        
var startCarPosition = new THREE.Vector3(0,3, 1);
        
var carAccel = 0.3;
var carBreak = 0.3;
var carDecel = 0.01;
var carSpeed = 0;
var carMaxSpeed = 1.2;        
        
var carWidth = 1;
var carHeight = carWidth/3;
var carDepth = carWidth*2;
        
var baseGeometry = new THREE.BoxGeometry( carWidth, carHeight, carDepth ); 
var baseMaterial = new THREE.MeshLambertMaterial( { color: 0xcc0000 } ); 
var headGeometry = new THREE.BoxGeometry( carWidth*0.7, carHeight*0.7, carDepth*0.6 ); 
var headMaterial = new THREE.MeshLambertMaterial( { color: 0xddeded } ); 
var wheelGeometry = new THREE.CylinderGeometry( carHeight/2, carHeight/2, carHeight/2 );
var wheelMaterial = new THREE.MeshLambertMaterial( {color: 0x221111} );
        
var base    = new THREE.Mesh(baseGeometry, baseMaterial);
var head    = new THREE.Mesh(headGeometry, headMaterial);
var FLwheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
var FRwheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
var RLwheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
var RRwheel = new THREE.Mesh(wheelGeometry, wheelMaterial);

head.position.y += carHeight;

FLwheel.position.z -= carDepth/2*0.75;
FLwheel.position.y -= carHeight/2;
FLwheel.position.x -= carWidth/2;
FLwheel.rotation.z -= Math.PI/2;

FRwheel.position.z -= carDepth/2*0.75;
FRwheel.position.y -= carHeight/2;
FRwheel.position.x += carWidth/2;
FRwheel.rotation.z -= Math.PI/2;

RLwheel.position.z += carDepth/2*0.75;
RLwheel.position.y -= carHeight/2;
RLwheel.position.x -= carWidth/2;
RLwheel.rotation.z -= Math.PI/2;

RRwheel.position.z += carDepth/2*0.75;
RRwheel.position.y -= carHeight/2;
RRwheel.position.x += carWidth/2;
RRwheel.rotation.z -= Math.PI/2;

car.add(base);
car.add(head);
car.add(FLwheel);
car.add(FRwheel);
car.add(RLwheel);
car.add(RRwheel);

car.position = startCarPosition;
scene.add(car);
        

// --------------
// ROAD        
// --------------

// --- TILE --------------
//
//       8---------7
//      /|        /|
//     / |       / |
//    /  |      /  |
//   5---------6   |
//   |   4-----|---3
//   | /       | /
//   1---------2
//   

var tileDepth = 5;
var tileHeight = 1;
var tileRoadWidth = 25;
var tileRumbleWidth = 3;        
        
var tileRoadGeometry = new THREE.BoxGeometry(tileRoadWidth, tileDepth, tileHeight);
var tileRumbleGeometry = new THREE.BoxGeometry(tileRumbleWidth, tileDepth, tileHeight);        
var tileRoadMaterial = new THREE.MeshBasicMaterial({ color: 0x6B6B6B, ambient: 0x6B6B6B });
var tileRoadMaterial2 = new THREE.MeshBasicMaterial({ color: 0x797979, ambient: 0x696969 });
var tileRumbleMaterial = new THREE.MeshBasicMaterial({ color: 0xCC0000, ambient: 0x6B6B6B });
var tileRumbleMaterial2 = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, ambient: 0x696969 });

function createTile(points, n) {
    var Tile = new THREE.Object3D();

    // Road
    var geometry = new THREE.BufferGeometry();

    var vertices = new Float32Array( [
        //top
        points.p5.x, points.p5.y, points.p5.z,
        points.p6.x, points.p6.y, points.p6.z,
        points.p7.x, points.p7.y, points.p7.z,
        points.p7.x, points.p7.y, points.p7.z,
        points.p8.x, points.p8.y, points.p8.z,
        points.p5.x, points.p5.y, points.p5.z,
      
        //bottom
        points.p1.x, points.p1.y, points.p1.z,
        points.p4.x, points.p4.y, points.p4.z,
        points.p3.x, points.p3.y, points.p3.z,
        points.p3.x, points.p3.y, points.p3.z,
        points.p2.x, points.p2.y, points.p2.z,
        points.p1.x, points.p1.y, points.p1.z,

        //front
        points.p1.x, points.p1.y, points.p1.z,
        points.p2.x, points.p2.y, points.p2.z,
        points.p6.x, points.p6.y, points.p6.z,
        points.p6.x, points.p6.y, points.p6.z,
        points.p5.x, points.p5.y, points.p5.z,
        points.p1.x, points.p1.y, points.p1.z,
        
        //back
        points.p4.x, points.p4.y, points.p4.z,
        points.p8.x, points.p8.y, points.p8.z,
        points.p7.x, points.p7.y, points.p7.z,
        points.p7.x, points.p7.y, points.p7.z,
        points.p3.x, points.p3.y, points.p3.z,
        points.p4.x, points.p4.y, points.p4.z,
        
        //left
        points.p4.x, points.p4.y, points.p4.z,
        points.p1.x, points.p1.y, points.p1.z,
        points.p5.x, points.p5.y, points.p5.z,
        points.p5.x, points.p5.y, points.p5.z,
        points.p8.x, points.p8.y, points.p8.z,
        points.p4.x, points.p4.y, points.p4.z,
        
        //right
        points.p2.x, points.p2.y, points.p2.z,
        points.p3.x, points.p3.y, points.p3.z,
        points.p7.x, points.p7.y, points.p7.z,
        points.p7.x, points.p7.y, points.p7.z,
        points.p6.x, points.p6.y, points.p6.z,
        points.p2.x, points.p2.y, points.p2.z,
    ]);
    
    geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );

    Tile.add(new THREE.Mesh(geometry,n%2 ? tileRoadMaterial : tileRoadMaterial2));
    var TileNum = THREE.TextGeometry
    
    // save original rumble points
    var rpoints = points;

    // Rumble Right
    var geometry = new THREE.BufferGeometry();  

    var m12 = (rpoints.p1.z-rpoints.p2.z)/(rpoints.p1.x-rpoints.p2.x);
    var m43 = (rpoints.p4.z-rpoints.p3.z)/(rpoints.p4.x-rpoints.p3.x);
    var angle12 = Math.atan(m12);
    var angle43 = Math.atan(m43);

    var dx12 = Math.cos(angle12)*tileRumbleWidth;
    var dz12 = Math.sin(angle12)*tileRumbleWidth;
    var dx43 = Math.cos(angle43)*tileRumbleWidth;
    var dz43 = Math.sin(angle43)*tileRumbleWidth;

   if(rpoints.p1.x > rpoints.p2.x){
        dx12 = -dx12;
        dz12 = -dz12;
    }

    if(rpoints.p4.x > rpoints.p3.x){
        dx43 = -dx43;
        dz43 = -dz43;
    }
    
    var points = {
        p1: rpoints.p2,
        p2: { 
            x: rpoints.p2.x + dx12, 
            y: rpoints.p2.y, 
            z: rpoints.p2.z + dz12 
        },
        p3: { 
            x: rpoints.p3.x + dx43, 
            y: rpoints.p3.y, 
            z: rpoints.p3.z + dz43 
        },
        p4: rpoints.p3,
        p5: rpoints.p6,
        p6: { 
            x: rpoints.p6.x + dx12, 
            y: rpoints.p6.y, 
            z: rpoints.p6.z + dz12 
        },
        p7: { 
            x: rpoints.p7.x + dx43, 
            y: rpoints.p7.y, 
            z: rpoints.p7.z + dz43 
        },
        p8: rpoints.p7
    }

    var vertices = new Float32Array( [
        //top 
        points.p5.x, points.p5.y, points.p5.z,
        points.p6.x, points.p6.y, points.p6.z,
        points.p7.x, points.p7.y, points.p7.z,
        points.p7.x, points.p7.y, points.p7.z,
        points.p8.x, points.p8.y, points.p8.z,
        points.p5.x, points.p5.y, points.p5.z,

        //bottom
        points.p1.x, points.p1.y, points.p1.z,
        points.p4.x, points.p4.y, points.p4.z,
        points.p3.x, points.p3.y, points.p3.z,
        points.p3.x, points.p3.y, points.p3.z,
        points.p2.x, points.p2.y, points.p2.z,
        points.p1.x, points.p1.y, points.p1.z,

        //front
        points.p1.x, points.p1.y, points.p1.z,
        points.p2.x, points.p2.y, points.p2.z,
        points.p6.x, points.p6.y, points.p6.z,
        points.p6.x, points.p6.y, points.p6.z,
        points.p5.x, points.p5.y, points.p5.z,
        points.p1.x, points.p1.y, points.p1.z,
        
        //back
        points.p4.x, points.p4.y, points.p4.z,
        points.p8.x, points.p8.y, points.p8.z,
        points.p7.x, points.p7.y, points.p7.z,
        points.p7.x, points.p7.y, points.p7.z,
        points.p3.x, points.p3.y, points.p3.z,
        points.p4.x, points.p4.y, points.p4.z,
        
        //left
        points.p4.x, points.p4.y, points.p4.z,
        points.p1.x, points.p1.y, points.p1.z,
        points.p5.x, points.p5.y, points.p5.z,
        points.p5.x, points.p5.y, points.p5.z,
        points.p8.x, points.p8.y, points.p8.z,
        points.p4.x, points.p4.y, points.p4.z,
        
        //right
        points.p2.x, points.p2.y, points.p2.z,
        points.p3.x, points.p3.y, points.p3.z,
        points.p7.x, points.p7.y, points.p7.z,
        points.p7.x, points.p7.y, points.p7.z,
        points.p6.x, points.p6.y, points.p6.z,
        points.p2.x, points.p2.y, points.p2.z,
    ]);
    
    geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
    
    Tile.add(new THREE.Mesh(geometry,n%2 ? tileRumbleMaterial : tileRumbleMaterial2));

    // Rumble Left
    var geometry = new THREE.BufferGeometry();  

    var m12 = (rpoints.p1.z-rpoints.p2.z)/(rpoints.p1.x-rpoints.p2.x);
    var m43 = (rpoints.p4.z-rpoints.p3.z)/(rpoints.p4.x-rpoints.p3.x);
    var angle12 = Math.atan(m12);
    var angle43 = Math.atan(m43);

    var dx12 = Math.cos(angle12)*tileRumbleWidth;
    var dz12 = Math.sin(angle12)*tileRumbleWidth;
    var dx43 = Math.cos(angle43)*tileRumbleWidth;
    var dz43 = Math.sin(angle43)*tileRumbleWidth;

   if(rpoints.p1.x > rpoints.p2.x){
        dx12 = -dx12;
        dz12 = -dz12;
    }

    if(rpoints.p4.x > rpoints.p3.x){
        dx43 = -dx43;
        dz43 = -dz43;
    }
    
    
    var points = {
        p1: { 
            x: rpoints.p1.x - dx12, 
            y: rpoints.p1.y, 
            z: rpoints.p1.z - dz12 
        },
        p2: rpoints.p1,
        p3: rpoints.p4,
        p4: { 
            x: rpoints.p4.x - dx43, 
            y: rpoints.p4.y, 
            z: rpoints.p4.z - dz43 
        },
        p5: { 
            x: rpoints.p5.x - dx12, 
            y: rpoints.p5.y, 
            z: rpoints.p5.z - dz12 
        },
        p6: rpoints.p5,
        p7: rpoints.p8,
        p8: { 
            x: rpoints.p8.x - dx43, 
            y: rpoints.p8.y, 
            z: rpoints.p8.z - dz43 
        },
    }

    var vertices = new Float32Array( [
        //top 
        points.p5.x, points.p5.y, points.p5.z,
        points.p6.x, points.p6.y, points.p6.z,
        points.p7.x, points.p7.y, points.p7.z,
        points.p7.x, points.p7.y, points.p7.z,
        points.p8.x, points.p8.y, points.p8.z,
        points.p5.x, points.p5.y, points.p5.z,

        //bottom
        points.p1.x, points.p1.y, points.p1.z,
        points.p4.x, points.p4.y, points.p4.z,
        points.p3.x, points.p3.y, points.p3.z,
        points.p3.x, points.p3.y, points.p3.z,
        points.p2.x, points.p2.y, points.p2.z,
        points.p1.x, points.p1.y, points.p1.z,

        //front
        points.p1.x, points.p1.y, points.p1.z,
        points.p2.x, points.p2.y, points.p2.z,
        points.p6.x, points.p6.y, points.p6.z,
        points.p6.x, points.p6.y, points.p6.z,
        points.p5.x, points.p5.y, points.p5.z,
        points.p1.x, points.p1.y, points.p1.z,
        
        //back
        points.p4.x, points.p4.y, points.p4.z,
        points.p8.x, points.p8.y, points.p8.z,
        points.p7.x, points.p7.y, points.p7.z,
        points.p7.x, points.p7.y, points.p7.z,
        points.p3.x, points.p3.y, points.p3.z,
        points.p4.x, points.p4.y, points.p4.z,
        
        //left
        points.p4.x, points.p4.y, points.p4.z,
        points.p1.x, points.p1.y, points.p1.z,
        points.p5.x, points.p5.y, points.p5.z,
        points.p5.x, points.p5.y, points.p5.z,
        points.p8.x, points.p8.y, points.p8.z,
        points.p4.x, points.p4.y, points.p4.z,
        
        //right
        points.p2.x, points.p2.y, points.p2.z,
        points.p3.x, points.p3.y, points.p3.z,
        points.p7.x, points.p7.y, points.p7.z,
        points.p7.x, points.p7.y, points.p7.z,
        points.p6.x, points.p6.y, points.p6.z,
        points.p2.x, points.p2.y, points.p2.z,
    ]);
    
    geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
    
    Tile.add(new THREE.Mesh(geometry,n%2 ? tileRumbleMaterial : tileRumbleMaterial2));

    return Tile;
}        


// ---- Segment --------------

function createSegment(prevTile, nTiles, curveType, curveRadius, elevationType, maxElevation){
    var roadSegment = new THREE.Object3D();
    for(var n=0; n<nTiles; n++){
        var curve = curveType(0, curveRadius, n/nTiles) + prevTile.curve;
        var elevation = elevationType(0, maxElevation, n/nTiles);

        var p1, p2, p3, p4;
        if(curve>0){
            p4 = {
                x: prevTile.p4.x + Math.sin(curve) * tileDepth,
                y: prevTile.p4.y + elevation + prevTile.elevation > 0 ? prevTile.p4.y + elevation + prevTile.elevation : 0, 
                z: prevTile.p4.z - Math.cos(curve) * tileDepth
            };
            p3 = {
                x: p4.x + Math.cos(curve) * tileRoadWidth,
                y: p4.y, 
                z: p4.z + Math.sin(curve) * tileRoadWidth
            };
        }else{
            p3 = {
                x: prevTile.p3.x - Math.sin(curve) * tileDepth,
                y: prevTile.p3.y + elevation + prevTile.elevation > 0 ? prevTile.p3.y + elevation + prevTile.elevation : 0, 
                z: prevTile.p3.z - Math.cos(curve) * tileDepth
            };
            p4 = {
                x: p3.x - Math.cos(curve) * tileRoadWidth,
                y: p3.y, 
                z: p3.z + Math.sin(curve) * tileRoadWidth
            };
        }

        p1 = prevTile.p4;
        p2 = prevTile.p3;
        var newTile = {
            p1: p1,
            p2: p2,
            p3: p3,
            p4: p4,
            p5: { x: p1.x, y: p1.y + tileHeight, z: p1.z },
            p6: { x: p2.x, y: p2.y + tileHeight, z: p2.z },
            p7: { x: p3.x, y: p3.y + tileHeight, z: p3.z },
            p8: { x: p4.x, y: p4.y + tileHeight, z: p4.z },

            curve: curve,
            elevation: elevation  + prevTile.elevation
        };
                
        var tile = createTile(newTile, n);

        roadSegment.add(tile);   
        prevTile = newTile;
    }

    return { segment: roadSegment, lastTile: newTile };
}

// ---- Road --------------

var road = new THREE.Object3D();
        
var nTiles = 10;
var nSegments = 40;
var functionTypes = [easeIn, easeOut, easeInOut];

var prevTile = { p3: { x:tileRoadWidth/2, y:0, z:0 },  p4: { x:-tileRoadWidth/2, y:0, z:0 },  curve: 0, elevation: 0};

for(var n=0; n<nSegments; n++){
    curveType = randomChoice(functionTypes);    
    elevationType = randomChoice(functionTypes);

    curveRadius = (Math.random()-0.5)*(tileDepth/tileRoadWidth);    
    elevation = (Math.random()-0.5)/2;

    segment = createSegment(prevTile, nTiles, curveType, curveRadius, elevationType, elevation);

    prevTile = segment.lastTile;
    road.add(segment.segment);
}
scene.add(road);
        
        
//=========================================================================
// UPDATE
//=========================================================================

var direction = new THREE.Vector3(0, -1, 0);
direction.normalize();

function update(){
    var carFLPoint = new THREE.Vector3(FLwheel.position.x, FLwheel.position.y, FLwheel.position.z+0.1);
    var carFRPoint = new THREE.Vector3(FRwheel.position.x, FRwheel.position.y, FRwheel.position.z+0.1);
    var carRLPoint = new THREE.Vector3(RLwheel.position.x, RLwheel.position.y, RLwheel.position.z+0.1);
    var carRRPoint = new THREE.Vector3(RRwheel.position.x, RRwheel.position.y, RRwheel.position.z+0.1);   
    var carPoint = new THREE.Vector3(car.position.x, car.position.y, car.position.z);
    var carPoint2 = new THREE.Vector3(car.position.x+carWidth/4, car.position.y, car.position.z);
    var carPoint3 = new THREE.Vector3(car.position.x, car.position.y, car.position.z+carDepth/4);

    var points = [carFLPoint,carFRPoint,carRLPoint,carRRPoint,carPoint,carPoint2,carPoint3];
    
    var maxy=-10000;
    for(var i=0;i<points.length;i++){
        var ray = new THREE.Raycaster(points[i], direction); 

        var rayIntersects = ray.intersectObjects(scene.children, true);    
    
        if (rayIntersects[0]){
            if(rayIntersects[0].point.y > maxy){
                maxy = rayIntersects[0].point.y;
            }
        }
    }
    
     if(maxy>0.1) car.position.y = maxy + carHeight;
     else car.position.y -= 0.5;
        
    if(keyLeft){
        camera.rotation.y -= 0.001;
        if(carSpeed<0)
            car.rotation.y -= 0.02;
        else
            car.rotation.y += 0.01;
    }
    else if(keyRight){
        camera.rotation.y += 0.001;

        if(carSpeed<0)
            car.rotation.y += 0.02;
        else
            car.rotation.y -= 0.01;
    }
    
    if(keyFaster){
        carSpeed += carAccel;
    }
    else if(keySlower){
        carSpeed -= carBreak;
    }else if(carSpeed > 0) {
        carSpeed -= carDecel;
        if(carSpeed<0)
            carSpeed=0
    }else if(carSpeed < 0) {
        carSpeed += carDecel;
        if(carSpeed>0)
            carSpeed=0
    }

    carSpeed = limit(carSpeed, -carMaxSpeed/2, carMaxSpeed);
    
    if(keyUp){
        car.position.y += 1;
    }
    if(keyDown){
        car.position.y -= 1;
    }
    
    if(car.position.y<startCarPosition.y) car.position.y=startCarPosition.y;
    
    car.position.z -= Math.cos(car.rotation.y)*carSpeed;
    car.position.x -= Math.sin(car.rotation.y)*carSpeed;
    
    camera.position.x = car.position.x;
    camera.position.y = car.position.y + cameraHeight;
    camera.position.z = car.position.z;
    camera.position.z += Math.cos(car.rotation.y)*cameraDistance;
    camera.position.x += Math.sin(car.rotation.y)*cameraDistance;

    camera.lookAt(car.position);

    spdy =  (screenH / 2 - mouseY) / 80;
    spdx =  (screenW / 2 - mouseX) / 80;
    if (mouseDown){
        camera.rotation.x = spdy;
        camera.rotation.y = spdx;
    }
}
 
//=========================================================================
// KEY LISTENERS
//=========================================================================
var keyLeft        = false;
var keyRight       = false;
var keyFaster      = false;
var keySlower      = false;        
var keyUp          = false;
var keyDown        = false;
        
function addEventListeners() {
    var KEY = { LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, A: 65, D: 68, S: 83, W: 87, Q: 81, E: 69 };
    var keys = [
        { keys: [KEY.LEFT,  KEY.A], mode: 'down', action: function() { keyLeft   = true;  } },
        { keys: [KEY.RIGHT, KEY.D], mode: 'down', action: function() { keyRight  = true;  } },
        { keys: [KEY.UP,    KEY.W], mode: 'down', action: function() { keyFaster = true;  } },
        { keys: [KEY.DOWN,  KEY.S], mode: 'down', action: function() { keySlower = true;  } },
        { keys: [KEY.Q],            mode: 'down', action: function() { keyUp     = true; } },
        { keys: [KEY.E],            mode: 'down', action: function() { keyDown   = true; } },
        { keys: [KEY.LEFT,  KEY.A], mode: 'up',   action: function() { keyLeft   = false; } },
        { keys: [KEY.RIGHT, KEY.D], mode: 'up',   action: function() { keyRight  = false; } },
        { keys: [KEY.UP,    KEY.W], mode: 'up',   action: function() { keyFaster = false; } },
        { keys: [KEY.DOWN,  KEY.S], mode: 'up',   action: function() { keySlower = false; } },
        { keys: [KEY.Q],            mode: 'up',   action: function() { keyUp     = false; } },
        { keys: [KEY.E],            mode: 'up',   action: function() { keyDown   = false; } }

    ];

    var onkey = function(keyCode, mode) {
        var n, k;
        for(n = 0 ; n < keys.length ; n++) {
            k = keys[n];
            k.mode = k.mode || 'up';
            if((k.key == keyCode || (k.keys && (k.keys.indexOf(keyCode) >= 0))) && k.mode == mode) k.action.call();
        }
    };

    document.addEventListener('keydown',function(ev) { onkey(ev.keyCode, 'down'); });
    document.addEventListener('keyup',function(ev) { onkey(ev.keyCode, 'up'); });
}

var screenW = window.innerWidth;
var screenH = window.innerHeight;
var spdx = 0, spdy = 0; mouseX = 0, mouseY = 0, mouseDown = false;
document.addEventListener('mousemove', function(event) {
    mouseX = event.clientX;
    mouseY = event.clientY;
}, false);
document.body.addEventListener("mousedown", function(event) {
    mouseDown = true
}, false);
document.body.addEventListener("mouseup", function(event) {
    mouseDown = false
}, false);

function animate() {    

}
        
//=========================================================================
// THE MAIN GAME LOOP
//=========================================================================

addEventListeners();

function render() { 
    requestAnimationFrame( render ); 
    update();
    renderer.render( scene, camera ); 
} 

render();    
    
</script> 
</body> </html>